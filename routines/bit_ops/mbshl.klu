0000	0100000B
0001	020000CF
0002	0120000D
0003	020000CD
0004	0100000C
0005	020000CE
0006	01000015
0007	0620000A
0008	020000CC
0009	04200016
000A	08000000
000B	00000002 		toShift
000C	00000008 		myArrSize
000D	FFFF0000
000E	FFFF0000
000F	FFFF0000
0010	FFFF0000
0011	FFFF0000
0012	FFFF0000
0013	FFFF0000
0014	FFFF0000
0015	04200000
0016	010000CF
0017	05200019 		toShift  is  not  zero?
0018	042000CC
0019	020001F0
001A	01000015
001B	0620001E
001C	020001F1
001D	042001DA
001E	010001F0 		is  toShift  greater  than  zero
001F	052000CC
0020	010000CE
0021	05200023 		array  size  not  zero?
0022	042000CC
0023	0620FFFF
0024	05200026 		array  size  greater  than  1?
0025	04200079 		if  not  then  work  on  one  cell
0026	01200000
0027	020000D1
0028	020000D2
0029	010000CF
002A	0620FFE0
002B	0520002D
002C	04200034
002D	020001F0 		if  toShift  is  greater  than  size  of  dword  (32  bits)
002E	01000015
002F	06200032
0030	020001F1
0031	042001DA
0032	010001F0
0033	05200071
0034	010000CF 		Big  shift  here
0035	02000218
0036	01200005 		toShift  >>  5  goes  to  array  shifting  routine
0037	02000217
0038	01000015
0039	0620003C
003A	02000216
003B	042001F2
003C	020000D1
003D	020001D7
003E	01000015
003F	06200042 		arrSize  -  shiftVal  must  be  greater  than  0
0040	020001D6
0041	042001CA
0042	020000D2
0043	060000CE
0044	05200046
0045	04200062
0046	020001F0
0047	01000015
0048	0620004B 		check  that  it  is  bigger
0049	020001F1
004A	042001DA
004B	010001F0 		if  shiftVal  too  big,
004C	05200062 		clear  the  array  instead  of  shifting
004D	010000D1 		prepare  to  shift  array  cell  by  cell
004E	0200013E
004F	010000CD
0050	0200013F
0051	010000CE
0052	02000140
0053	01000015
0054	06200057
0055	0200013D
0056	04200117
0057	010000CF
0058	02000241
0059	0120001F 		bit  mask  for  all  under  32
005A	02000242
005B	01000015
005C	0620005F
005D	02000240
005E	0420021D
005F	020000CF
0060	05200071
0061	042000CC
0062	010000CD
0063	020000D3
0064	01200000
0065	020000D5
0066	01200000
0067	024000D3
0068	010000D3
0069	06200001
006A	020000D3
006B	010000D5
006C	0620FFFF
006D	020000D5
006E	060000CE
006F	05200066
0070	042000CC
0071	010000CD 		load  values
0072	020000D3
0073	06200001
0074	020000D4
0075	010000CE
0076	0620FFFF
0077	020000D6
0078	0520007D
0079	014000CD 		if  not,  just  work  on  single  cell
007A	070000CF
007B	024000CD
007C	042000CC
007D	01200000
007E	020000D5
007F	014000D3 		unpack  values
0080	020001C5
0081	012000D7
0082	020001C6
0083	01000015
0084	06200087
0085	020001C4
0086	042001AA
0087	014000D4
0088	020001C5
0089	012000F7
008A	020001C6
008B	01000015
008C	0620008F
008D	020001C4
008E	042001AA
008F	010000CF
0090	02000173
0091	012000D7
0092	02000172
0093	01000015
0094	06200097
0095	02000171
0096	04200144
0097	010000CF
0098	02000194
0099	012000F7
009A	02000192
009B	012000D7
009C	02000193
009D	01000015
009E	062000A1
009F	02000191
00A0	04200177
00A1	012000D7
00A2	020001A7
00A3	01000015
00A4	062000A7
00A5	020001A5
00A6	04200196
00A7	010001A6
00A8	024000D3
00A9	010000D3
00AA	06200001
00AB	020000D3
00AC	010000D4
00AD	06200001
00AE	020000D4
00AF	010000D5
00B0	0620FFFF
00B1	020000D5
00B2	060000D6
00B3	0520007F
00B4	014000D3 		unpack  last  value
00B5	020001C5
00B6	012000D7
00B7	020001C6
00B8	01000015
00B9	062000BC
00BA	020001C4
00BB	042001AA
00BC	010000CF
00BD	02000173
00BE	012000D7
00BF	02000172
00C0	01000015
00C1	062000C4
00C2	02000171
00C3	04200144
00C4	012000D7
00C5	020001A7
00C6	01000015
00C7	062000CA
00C8	020001A5
00C9	04200196
00CA	010001A6
00CB	024000D3
00CC	00000000
00CD	00000000 		MBptrArray
00CE	00000000 		MBarrSize
00CF	00000000 		MBtoShift
00D0	0000001F
00D1	00000000 		MBbigShVal
00D2	00000000 		MBnegBigSh
00D3	00000000 		MBptrVal1
00D4	00000000 		MBptrVal2
00D5	00000000
00D6	00000000
00D7	00000000
00D8	00000000
00D9	00000000
00DA	00000000
00DB	00000000
00DC	00000000
00DD	00000000
00DE	00000000
00DF	00000000
00E0	00000000
00E1	00000000
00E2	00000000
00E3	00000000
00E4	00000000
00E5	00000000
00E6	00000000
00E7	00000000
00E8	00000000
00E9	00000000
00EA	00000000
00EB	00000000
00EC	00000000
00ED	00000000
00EE	00000000
00EF	00000000
00F0	00000000
00F1	00000000
00F2	00000000
00F3	00000000
00F4	00000000
00F5	00000000
00F6	00000000
00F7	00000000
00F8	00000000
00F9	00000000
00FA	00000000
00FB	00000000
00FC	00000000
00FD	00000000
00FE	00000000
00FF	00000000
0100	00000000
0101	00000000
0102	00000000
0103	00000000
0104	00000000
0105	00000000
0106	00000000
0107	00000000
0108	00000000
0109	00000000
010A	00000000
010B	00000000
010C	00000000
010D	00000000
010E	00000000
010F	00000000
0110	00000000
0111	00000000
0112	00000000
0113	00000000
0114	00000000
0115	00000000
0116	00000000
0117	0100013E
0118	0520011A
0119	0420013D
011A	020001D7
011B	0120011F
011C	06000015
011D	020001D6
011E	042001CA
011F	06000140
0120	02000141
0121	0100013F
0122	02000143
0123	0600013E
0124	02000142
0125	01400142
0126	02400143
0127	01000142
0128	06200001
0129	02000142
012A	01000143
012B	06200001
012C	02000143
012D	01000141
012E	0620FFFF
012F	02000141
0130	05200125
0131	01200000
0132	02000141
0133	01200000
0134	02400143
0135	01000143
0136	06200001
0137	02000143
0138	01000141
0139	0620FFFF
013A	02000141
013B	0600013E
013C	05200133
013D	00000000
013E	00000000
013F	00000000
0140	00000000
0141	00000000
0142	00000000
0143	00000000
0144	01000173
0145	05200147
0146	04200171 		zero  case
0147	0620FFE0
0148	0520014A 		max  case
0149	04200163
014A	01000173
014B	020001D7
014C	01200150
014D	06000015
014E	020001D6
014F	042001CA
0150	06200020 		Negate's  Nvalue  is  in  accumulator  now
0151	02000174 		index  is  (size  -  toShift)
0152	0620FFFF 		arrays  are  zero  indexed  so  offset  it  by  one
0153	06000172
0154	02000175
0155	06000173
0156	02000176
0157	01400175 		shift  goes  here
0158	02400176
0159	01000175
015A	0620FFFF
015B	02000175
015C	01000176
015D	0620FFFF
015E	02000176
015F	01000174
0160	0620FFFF
0161	02000174
0162	05200157
0163	01000173
0164	02000174
0165	0620FFFF
0166	06000172
0167	02000176
0168	01200000
0169	02400176
016A	01000176
016B	0620FFFF
016C	02000176
016D	01000174
016E	0620FFFF
016F	02000174
0170	05200168
0171	00000000 		USHreturn
0172	00000000 		USHbufPtr
0173	00000000
0174	00000000 		USHindex
0175	00000000 		USHsrcPtr
0176	00000000 		USHdestPtr
0177	01000194
0178	0520017A
0179	04200191
017A	020001D7
017B	01000015
017C	0620017F
017D	020001D6
017E	042001CA
017F	06200020
0180	02000195
0181	01000192 		carry  bits  are  in  index  offset:  size  -  toShift
0182	06000195 		update  pointer  accordingly
0183	02000192
0184	01400192
0185	02400193
0186	01000192
0187	06200001
0188	02000192
0189	01000193
018A	06200001
018B	02000193
018C	01000195
018D	06200001
018E	02000195
018F	0620FFE0
0190	05200184
0191	00000000
0192	00000000
0193	00000000
0194	00000000
0195	00000000
0196	01200000
0197	020001A8
0198	020001A6
0199	014001A7 		retrieve  bit  at  indexed  location
019A	070001A8 		shift  to  its  proper  position
019B	060001A6 		pack  into  the  result
019C	020001A6 		and  save  it
019D	010001A7
019E	06200001
019F	020001A7
01A0	010001A8
01A1	06200001
01A2	020001A8 		update  position
01A3	060001A9 		is  PKcurrPos  less  than  32  (PKlimit)?
01A4	05200199
01A5	00000000
01A6	00000000
01A7	00000000
01A8	00000000
01A9	FFFFFFE0 		PKlimit
01AA	010001C5
01AB	020001C9
01AC	01200000
01AD	020001C7
01AE	01200020 		number  of  bits  in  an  addressed  value
01AF	0620FFFF
01B0	020001C8 		update  distance  from  big  (left)  end  of  value
01B1	010001C9 		get  bit
01B2	070001C8
01B3	052001B6
01B4	01200000 		store  bit  in  accumulator
01B5	042001BB
01B6	0120FFFF
01B7	070001C7 		if  set  -  clear  this  bit
01B8	060001C9
01B9	020001C9
01BA	01200001 		store  bit  in  accumulator
01BB	024001C6
01BC	010001C6
01BD	06200001
01BE	020001C6
01BF	010001C7 		update  UPcurrPos
01C0	06200001
01C1	020001C7
01C2	010001C8 		if  more  bits  to  shift
01C3	052001AF 		start  over
01C4	00000000
01C5	00000000 		packed  Value
01C6	00000000
01C7	00000000
01C8	00000000
01C9	00000000 		working  value
01CA	010001D7
01CB	020001D8
01CC	01200020
01CD	0620FFFF
01CE	020001D9
01CF	010001D7
01D0	07200001
01D1	060001D8
01D2	020001D7
01D3	010001D9
01D4	052001CD
01D5	010001D7
01D6	00000000
01D7	00000000 		Nvalue
01D8	00000000 		N  old  value
01D9	00000000 		N  counter
01DA	0120001F
01DB	020001EE
01DC	01200000
01DD	020001EF
01DE	010001F0
01DF	070001EE 		shl
01E0	052001E2
01E1	042001E6
01E2	0120FFFF
01E3	070001EF
01E4	060001F0
01E5	020001F0
01E6	010001EF
01E7	06200001
01E8	020001EF
01E9	010001EE
01EA	0620FFFF
01EB	020001EE
01EC	052001DE
01ED	042001F1
01EE	00000000 		position  relative  to  HO  bit
01EF	00000000 		position  relative  to  LO  bit
01F0	00000000 		NTtoTest
01F1	00000000 		NTtoReturn
01F2	01200000
01F3	0200021C
01F4	0200021B
01F5	0200021A
01F6	01200020
01F7	0620FFFF
01F8	02000219
01F9	01000218
01FA	07000219 		test  lowest  bit
01FB	052001FF
01FC	01000217
01FD	0520020A
01FE	0420020D
01FF	0120FFFF
0200	0700021C 		clear  bit
0201	06000218
0202	02000218
0203	01000217 		are  we  ready  to  write  yet?
0204	0520020A
0205	01200001 		send  bit  to  SHRresult
0206	0700021B
0207	0600021A
0208	0200021A
0209	0420020D
020A	0620FFFF
020B	02000217
020C	04200210
020D	0100021B 		update  shiftCount
020E	06200001
020F	0200021B
0210	0100021C
0211	06200001
0212	0200021C
0213	01000219
0214	052001F7
0215	0100021A
0216	00000000 		SHRreturn
0217	00000000 		SHRshiftYet
0218	00000000 		SHRworkingVal
0219	00000020 		SHRfromLeft
021A	00000000 		SHRresult
021B	00000000 		SHRshiftCount
021C	00000000 		SHRuCount
021D	01200000
021E	02000245
021F	02000244
0220	01200020
0221	0620FFFF
0222	02000243
0223	01000241
0224	07000243
0225	0520022A
0226	01000242
0227	07000243
0228	05200236
0229	0420023A
022A	0120FFFF
022B	07000245 		clear  bit
022C	06000241
022D	02000241
022E	01000242
022F	07000243
0230	05200232
0231	0420023A
0232	01200001 		1  and  2  both  set
0233	07000245 		so  set  ANDresult  bit
0234	06000244
0235	02000244
0236	0120FFFF
0237	07000245 		clear  bit
0238	06000242
0239	02000242
023A	01000245
023B	06200001
023C	02000245
023D	01000243
023E	05200221
023F	01000244
0240	00000000
0241	00000000 		ANDval1
0242	00000000 		ANDval2
0243	00000000 		ANDfromLeft
0244	00000000 		ANDresult
0245	00000000 		ANDuCount

99999
000B 000C 000D 000E 000F 0010 0011 0012 0013 0014