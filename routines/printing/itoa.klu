0000	01000007
0001	0200004B
0002	01000008
0003	06200006
0004	0200004A
0005	04200009
0006	08000000
0007	7FFFFFFF 		value  goes  here
0008	04200000
0009	01200000 		clear  buffer
000A	0200004C
000B	0200004D
000C	0200004E
000D	02000050
000E	03200002
000F	01200002
0010	02000051
0011	01200005
0012	0200004F
0013	0100004B
0014	05200018
0015	06200030 		zero  case
0016	0200004C
0017	0420004A
0018	020000C3
0019	0120000A
001A	020000C4
001B	01000008
001C	0620001F
001D	020000C2
001E	04200053
001F	01000050
0020	06200001
0021	02000050
0022	0100004F
0023	0620FFFF
0024	0200004F
0025	0520002E
0026	01200004 		reset  buf  counter
0027	0200004F
0028	01000051
0029	0620FFFF
002A	02000051
002B	03000051
002C	01200000
002D	02000052
002E	010000C6
002F	06200030
0030	07000052
0031	0680004C
0032	0280004C
0033	01000052
0034	06200008
0035	02000052
0036	010000C5
0037	0200004B
0038	05200018
0039	01000050
003A	020000F3
003B	01000008 		prepare  to  shift  values  to  head  of  array
003C	0620003F
003D	020000F2
003E	042000E6
003F	0620000C 		shift  value  is  (12  -  DivCnt)  *  8
0040	07200003
0041	020001D0
0042	01200003
0043	020001CF
0044	0120004C
0045	020001CE
0046	01000008
0047	0620004A
0048	020001CD
0049	04200117
004A	00000000
004B	00000000 		atoi  working  value
004C	00000000
004D	00000000
004E	00000000 		atoi  buffer
004F	00000000
0050	00000000 		atoi  division  counter
0051	00000000
0052	00000000
0053	010000C4
0054	05200058
0055	01200001
0056	020000CC
0057	042000C2
0058	01200000
0059	020000C8
005A	020000C5
005B	010000C3
005C	020000E5
005D	01000008
005E	06200061
005F	020000E2
0060	042000CE
0061	05200063
0062	0420006D
0063	010000C8 		if  dividend  is  negative
0064	060000CD 		flip  sign  flag
0065	020000C8
0066	010000C3 		negate  dividend
0067	020000F3
0068	01000008
0069	0620006C
006A	020000F2
006B	042000E6
006C	020000C3
006D	010000C4
006E	020000E5
006F	01000008
0070	06200073
0071	020000E2
0072	042000CE
0073	0520007C
0074	010000C4 		if  divisor  is  positive
0075	020000F3 		negate  divisor
0076	01000008
0077	0620007A
0078	020000F2
0079	042000E6
007A	020000C4
007B	0420007F
007C	010000C8 		if  divisor  is  negative
007D	060000CD 		flip  sign  flag
007E	020000C8
007F	010000C3 		calculate  HO  bit  of  dividend
0080	02000115
0081	01200000
0082	02000114
0083	01000008
0084	06200087
0085	02000111
0086	042000F6
0087	020000C9
0088	010000C4 		calculate  HO  bit  of  divisor
0089	02000115
008A	01200001
008B	02000114
008C	01000008
008D	06200090
008E	02000111
008F	042000F6
0090	020000F3 		negate  marker  value
0091	01000008
0092	06200095
0093	020000F2
0094	042000E6
0095	060000C9 		dividend  HOpos  -  divisor  HOpos  =
0096	020000CB 		amount  needed  to  align  HO  bits
0097	020000E5 		double  check  to  ensure  we  don't
0098	01000008 		try  to  divide  if  divisor  is  greater
0099	0620009C 		than  dividend
009A	020000E2
009B	042000CE
009C	052000BF
009D	010000CB
009E	06200001
009F	0620FFFF
00A0	020000CB
00A1	010000C5 		shift  result  left  by  one  bit
00A2	07200001
00A3	020000C5
00A4	010000C4
00A5	070000CB 		bit  shift  divisor  so  that  its  HO  bit  aligns  with  dividend  HO  bit
00A6	060000C3 		add  modified  divisor  to  dividend
00A7	020000C7
00A8	020000E5
00A9	01000008
00AA	062000AD
00AB	020000E2 		check  to  see  if  result  is  negative
00AC	042000CE 		a  negative  result  implies  divisor  is  greater  than  dividend
00AD	052000B3
00AE	010000C7 		if  result  is  positive
00AF	020000C3 		save  dividend
00B0	010000C5 		add  1  to  result
00B1	06200001
00B2	020000C5
00B3	010000CB 		subtract  bit  shift  counter  by  1  and  save  it
00B4	0520009F
00B5	010000C8 		if  negative  then  quotient  must  be  negative
00B6	052000B8
00B7	042000BF
00B8	010000C5
00B9	020000F3
00BA	01000008
00BB	062000BE
00BC	020000F2
00BD	042000E6
00BE	020000C5
00BF	010000C3
00C0	020000C6
00C1	010000C5
00C2	0420FFFF 		DVreturn
00C3	00000000
00C4	00000000
00C5	00000000
00C6	00000000
00C7	00000000
00C8	00000000
00C9	00000000
00CA	00000000
00CB	00000000
00CC	00000000
00CD	80000000
00CE	0120001F
00CF	020000E3
00D0	01200000
00D1	020000E4
00D2	010000E5
00D3	070000E3 		shl
00D4	052000D6
00D5	042000DA
00D6	0120FFFF
00D7	070000E4
00D8	060000E5
00D9	020000E5
00DA	010000E4
00DB	06200001
00DC	020000E4
00DD	010000E3
00DE	0620FFFF
00DF	020000E3
00E0	052000D2
00E1	010000E5
00E2	00000000 		NTtoReturn
00E3	00000000 		position  relative  to  HO  bit
00E4	00000000 		position  relative  to  LO  bit
00E5	00000000 		NTtoTest
00E6	010000F3
00E7	020000F4
00E8	01200020
00E9	0620FFFF
00EA	020000F5
00EB	010000F3
00EC	07200001
00ED	060000F4
00EE	020000F3
00EF	010000F5
00F0	052000E9
00F1	010000F3
00F2	00000000
00F3	00000000 		Nvalue
00F4	00000000 		N  old  value
00F5	00000000 		N  counter
00F6	0120FFFF
00F7	02000116
00F8	01200000
00F9	02000113
00FA	01200020
00FB	0620FFFF
00FC	02000112
00FD	01000115
00FE	07000112
00FF	05200103
0100	01000114
0101	05200109
0102	0420010B
0103	0120FFFF
0104	07000113
0105	06000115
0106	02000115
0107	01000114
0108	0520010B
0109	01000113
010A	02000116
010B	01000113
010C	06200001
010D	02000113
010E	01000112
010F	052000FB
0110	01000116
0111	0420FFFF 		HOFtoReturn
0112	00000000 		position  relative  to  HO  bit
0113	00000000 		position  relative  to  LO  bit
0114	00000000 		HOFisNegative
0115	00000000 		HOFtoTest
0116	00000000 		HOFresult
0117	010001D0
0118	0520011A 		toShift  is  not  zero?
0119	042001CD
011A	020000E5
011B	01000008
011C	0620011F
011D	020000E2
011E	042000CE
011F	010000E5 		is  toShift  greater  than  zero
0120	052001CD
0121	010001CF
0122	05200124 		array  size  not  zero?
0123	042001CD
0124	0620FFFF
0125	05200127 		array  size  greater  than  1?
0126	0420017A 		if  not  then  work  on  one  cell
0127	01200000
0128	020001D2
0129	020001D3
012A	010001D0
012B	0620FFE0
012C	0520012E
012D	04200135
012E	020000E5 		if  toShift  is  greater  than  size  of  dword  (32  bits)
012F	01000008
0130	06200133
0131	020000E2
0132	042000CE
0133	010000E5
0134	05200172
0135	010001D0 		Big  shift  here
0136	020002F1
0137	01200005 		toShift  >>  5  goes  to  array  shifting  routine
0138	020002F0
0139	01000008
013A	0620013D
013B	020002EF
013C	042002CB
013D	020001D2
013E	020000F3
013F	01000008
0140	06200143 		arrSize  -  shiftVal  must  be  greater  than  0
0141	020000F2
0142	042000E6
0143	020001D3
0144	060001CF
0145	05200147
0146	04200163
0147	020000E5
0148	01000008
0149	0620014C 		check  that  it  is  bigger
014A	020000E2
014B	042000CE
014C	010000E5 		if  shiftVal  too  big,
014D	05200163 		clear  the  array  instead  of  shifting
014E	010001D2 		prepare  to  shift  array  cell  by  cell
014F	0200023F
0150	010001CE
0151	02000240
0152	010001CF
0153	02000241
0154	01000008
0155	06200158
0156	0200023E
0157	04200218
0158	010001D0
0159	0200031A
015A	0120001F 		bit  mask  for  all  under  32
015B	0200031B
015C	01000008
015D	06200160
015E	02000319
015F	042002F6
0160	020001D0
0161	05200172
0162	042001CD
0163	010001CE
0164	020001D4
0165	01200000
0166	020001D6
0167	01200000
0168	024001D4
0169	010001D4
016A	06200001
016B	020001D4
016C	010001D6
016D	0620FFFF
016E	020001D6
016F	060001CF
0170	05200167
0171	042001CD
0172	010001CE 		load  values
0173	020001D4
0174	06200001
0175	020001D5
0176	010001CF
0177	0620FFFF
0178	020001D7
0179	0520017E
017A	014001CE 		if  not,  just  work  on  single  cell
017B	070001D0
017C	024001CE
017D	042001CD
017E	01200000
017F	020001D6
0180	014001D4 		unpack  values
0181	020002C6
0182	012001D8
0183	020002C7
0184	01000008
0185	06200188
0186	020002C5
0187	042002AB
0188	014001D5
0189	020002C6
018A	012001F8
018B	020002C7
018C	01000008
018D	06200190
018E	020002C5
018F	042002AB
0190	010001D0
0191	02000274
0192	012001D8
0193	02000273
0194	01000008
0195	06200198
0196	02000272
0197	04200245
0198	010001D0
0199	02000295
019A	012001F8
019B	02000293
019C	012001D8
019D	02000294
019E	01000008
019F	062001A2
01A0	02000292
01A1	04200278
01A2	012001D8
01A3	020002A8
01A4	01000008
01A5	062001A8
01A6	020002A6
01A7	04200297
01A8	010002A7
01A9	024001D4
01AA	010001D4
01AB	06200001
01AC	020001D4
01AD	010001D5
01AE	06200001
01AF	020001D5
01B0	010001D6
01B1	0620FFFF
01B2	020001D6
01B3	060001D7
01B4	05200180
01B5	014001D4 		unpack  last  value
01B6	020002C6
01B7	012001D8
01B8	020002C7
01B9	01000008
01BA	062001BD
01BB	020002C5
01BC	042002AB
01BD	010001D0
01BE	02000274
01BF	012001D8
01C0	02000273
01C1	01000008
01C2	062001C5
01C3	02000272
01C4	04200245
01C5	012001D8
01C6	020002A8
01C7	01000008
01C8	062001CB
01C9	020002A6
01CA	04200297
01CB	010002A7
01CC	024001D4
01CD	00000000
01CE	00000000 		MBptrArray
01CF	00000000 		MBarrSize
01D0	00000000 		MBtoShift
01D1	0000001F
01D2	00000000 		MBbigShVal
01D3	00000000 		MBnegBigSh
01D4	00000000 		MBptrVal1
01D5	00000000 		MBptrVal2
01D6	00000000
01D7	00000000
01D8	00000000
01D9	00000000
01DA	00000000
01DB	00000000
01DC	00000000
01DD	00000000
01DE	00000000
01DF	00000000
01E0	00000000
01E1	00000000
01E2	00000000
01E3	00000000
01E4	00000000
01E5	00000000
01E6	00000000
01E7	00000000
01E8	00000000
01E9	00000000
01EA	00000000
01EB	00000000
01EC	00000000
01ED	00000000
01EE	00000000
01EF	00000000
01F0	00000000
01F1	00000000
01F2	00000000
01F3	00000000
01F4	00000000
01F5	00000000
01F6	00000000
01F7	00000000
01F8	00000000
01F9	00000000
01FA	00000000
01FB	00000000
01FC	00000000
01FD	00000000
01FE	00000000
01FF	00000000
0200	00000000
0201	00000000
0202	00000000
0203	00000000
0204	00000000
0205	00000000
0206	00000000
0207	00000000
0208	00000000
0209	00000000
020A	00000000
020B	00000000
020C	00000000
020D	00000000
020E	00000000
020F	00000000
0210	00000000
0211	00000000
0212	00000000
0213	00000000
0214	00000000
0215	00000000
0216	00000000
0217	00000000
0218	0100023F
0219	0520021B
021A	0420023E
021B	020000F3
021C	01200220
021D	06000008
021E	020000F2
021F	042000E6
0220	06000241
0221	02000242
0222	01000240
0223	02000244
0224	0600023F
0225	02000243
0226	01400243
0227	02400244
0228	01000243
0229	06200001
022A	02000243
022B	01000244
022C	06200001
022D	02000244
022E	01000242
022F	0620FFFF
0230	02000242
0231	05200226
0232	01200000
0233	02000242
0234	01200000
0235	02400244
0236	01000244
0237	06200001
0238	02000244
0239	01000242
023A	0620FFFF
023B	02000242
023C	0600023F
023D	05200234
023E	00000000
023F	00000000
0240	00000000
0241	00000000
0242	00000000
0243	00000000
0244	00000000
0245	01000274
0246	05200248
0247	04200272 		zero  case
0248	0620FFE0
0249	0520024B 		max  case
024A	04200264
024B	01000274
024C	020000F3
024D	01200251
024E	06000008
024F	020000F2
0250	042000E6
0251	06200020 		Negate's  Nvalue  is  in  accumulator  now
0252	02000275 		index  is  (size  -  toShift)
0253	0620FFFF 		arrays  are  zero  indexed  so  offset  it  by  one
0254	06000273
0255	02000276
0256	06000274
0257	02000277
0258	01400276 		shift  goes  here
0259	02400277
025A	01000276
025B	0620FFFF
025C	02000276
025D	01000277
025E	0620FFFF
025F	02000277
0260	01000275
0261	0620FFFF
0262	02000275
0263	05200258
0264	01000274
0265	02000275
0266	0620FFFF
0267	06000273
0268	02000277
0269	01200000
026A	02400277
026B	01000277
026C	0620FFFF
026D	02000277
026E	01000275
026F	0620FFFF
0270	02000275
0271	05200269
0272	00000000 		USHreturn
0273	00000000 		USHbufPtr
0274	00000000
0275	00000000 		USHindex
0276	00000000 		USHsrcPtr
0277	00000000 		USHdestPtr
0278	01000295
0279	0520027B
027A	04200292
027B	020000F3
027C	01000008
027D	06200280
027E	020000F2
027F	042000E6
0280	06200020
0281	02000296
0282	01000293 		carry  bits  are  in  index  offset:  size  -  toShift
0283	06000296 		update  pointer  accordingly
0284	02000293
0285	01400293
0286	02400294
0287	01000293
0288	06200001
0289	02000293
028A	01000294
028B	06200001
028C	02000294
028D	01000296
028E	06200001
028F	02000296
0290	0620FFE0
0291	05200285
0292	00000000
0293	00000000
0294	00000000
0295	00000000
0296	00000000
0297	01200000
0298	020002A9
0299	020002A7
029A	014002A8 		retrieve  bit  at  indexed  location
029B	070002A9 		shift  to  its  proper  position
029C	060002A7 		pack  into  the  result
029D	020002A7 		and  save  it
029E	010002A8
029F	06200001
02A0	020002A8
02A1	010002A9
02A2	06200001
02A3	020002A9 		update  position
02A4	060002AA 		is  PKcurrPos  less  than  32  (PKlimit)?
02A5	0520029A
02A6	00000000
02A7	00000000
02A8	00000000
02A9	00000000
02AA	FFFFFFE0 		PKlimit
02AB	010002C6
02AC	020002CA
02AD	01200000
02AE	020002C8
02AF	01200020 		number  of  bits  in  an  addressed  value
02B0	0620FFFF
02B1	020002C9 		update  distance  from  big  (left)  end  of  value
02B2	010002CA 		get  bit
02B3	070002C9
02B4	052002B7
02B5	01200000 		store  bit  in  accumulator
02B6	042002BC
02B7	0120FFFF
02B8	070002C8 		if  set  -  clear  this  bit
02B9	060002CA
02BA	020002CA
02BB	01200001 		store  bit  in  accumulator
02BC	024002C7
02BD	010002C7
02BE	06200001
02BF	020002C7
02C0	010002C8 		update  UPcurrPos
02C1	06200001
02C2	020002C8
02C3	010002C9 		if  more  bits  to  shift
02C4	052002B0 		start  over
02C5	00000000
02C6	00000000 		packed  Value
02C7	00000000
02C8	00000000
02C9	00000000
02CA	00000000 		working  value
02CB	01200000
02CC	020002F5
02CD	020002F4
02CE	020002F3
02CF	01200020
02D0	0620FFFF
02D1	020002F2
02D2	010002F1
02D3	070002F2 		test  lowest  bit
02D4	052002D8
02D5	010002F0
02D6	052002E3
02D7	042002E6
02D8	0120FFFF
02D9	070002F5 		clear  bit
02DA	060002F1
02DB	020002F1
02DC	010002F0 		are  we  ready  to  write  yet?
02DD	052002E3
02DE	01200001 		send  bit  to  SHRresult
02DF	070002F4
02E0	060002F3
02E1	020002F3
02E2	042002E6
02E3	0620FFFF
02E4	020002F0
02E5	042002E9
02E6	010002F4 		update  shiftCount
02E7	06200001
02E8	020002F4
02E9	010002F5
02EA	06200001
02EB	020002F5
02EC	010002F2
02ED	052002D0
02EE	010002F3
02EF	00000000 		SHRreturn
02F0	00000000 		SHRshiftYet
02F1	00000000 		SHRworkingVal
02F2	00000020 		SHRfromLeft
02F3	00000000 		SHRresult
02F4	00000000 		SHRshiftCount
02F5	00000000 		SHRuCount
02F6	01200000
02F7	0200031E
02F8	0200031D
02F9	01200020
02FA	0620FFFF
02FB	0200031C
02FC	0100031A
02FD	0700031C
02FE	05200303
02FF	0100031B
0300	0700031C
0301	0520030F
0302	04200313
0303	0120FFFF
0304	0700031E 		clear  bit
0305	0600031A
0306	0200031A
0307	0100031B
0308	0700031C
0309	0520030B
030A	04200313
030B	01200001 		1  and  2  both  set
030C	0700031E 		so  set  ANDresult  bit
030D	0600031D
030E	0200031D
030F	0120FFFF
0310	0700031E 		clear  bit
0311	0600031B
0312	0200031B
0313	0100031E
0314	06200001
0315	0200031E
0316	0100031C
0317	052002FA
0318	0100031D
0319	00000000
031A	00000000 		ANDval1
031B	00000000 		ANDval2
031C	00000000 		ANDfromLeft
031D	00000000 		ANDresult
031E	00000000 		ANDuCount

99999
0007 004C 004D 004E