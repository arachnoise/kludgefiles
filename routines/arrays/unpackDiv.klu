0000	04200000 		jump  instruction  code
0001	00000005 		packed  Value  1
0002	00000007 		packed  Value  2
0003	00000000 		division  result
0004	00000020
0005	00000000
0006	00000000
0007	00000000
0008	00000000
0009	00000000
000A	00000000
000B	00000000
000C	00000000
000D	00000000
000E	00000000
000F	00000000
0010	00000000
0011	00000000
0012	00000000
0013	00000000
0014	00000000
0015	00000000
0016	00000000
0017	00000000
0018	00000000
0019	00000000
001A	00000000
001B	00000000
001C	00000000
001D	00000000
001E	00000000
001F	00000000
0020	00000000
0021	00000000
0022	00000000
0023	00000000
0024	00000000
0025	00000000
0026	00000000
0027	00000000
0028	00000000
0029	00000000
002A	00000000
002B	00000000
002C	00000000
002D	00000000
002E	00000000
002F	00000000
0030	00000000
0031	00000000
0032	00000000
0033	00000000
0034	00000000
0035	00000000
0036	00000000
0037	00000000
0038	00000000
0039	00000000
003A	00000000
003B	00000000
003C	00000000
003D	00000000
003E	00000000
003F	00000000
0040	00000000
0041	00000000
0042	00000000
0043	00000000
0044	00000000
0045	01200000
0046	02000096
0047	02000097
0048	02000094
0049	0140008F
004A	0520004C
004B	04200054
004C	01000096
004D	06200001
004E	02000096
004F	0100008F
0050	06200001
0051	0200008F
0052	0140008F
0053	0520004C
0054	01400090
0055	05200057
0056	0420005F
0057	01000097
0058	06200001
0059	02000097
005A	01000090 		negative  value  simplifies  subtraction  later  on
005B	0620FFFF
005C	02000090
005D	01400090
005E	05200057
005F	01000097 		  divisor  start  -  dividend  start  >  0  ?
0060	06000096
0061	02000095
0062	020000B2
0063	01000000
0064	06200067
0065	020000B3
0066	0420009B
0067	05200093
0068	01000092
0069	06000096
006A	02000098
006B	01000090
006C	0200011F
006D	0100008F
006E	02000120
006F	01000098
0070	02000121
0071	01000000
0072	06200075
0073	02000122
0074	042000F7
0075	06200001
0076	05200078
0077	04200086
0078	01000091
0079	06200001
007A	02000091
007B	01000090
007C	020000E0
007D	0100008F
007E	020000E1
007F	01000090
0080	020000E2
0081	01000098
0082	020000E3
0083	01000000
0084	06200086
0085	020000E4
0086	01000091
0087	07200001
0088	02000091
0089	01000090
008A	06200001
008B	02000090
008C	0100008F
008D	06200001
008E	0200008F
008F	00000000 		  in  pointer
0090	00000000 		  in  pointer
0091	00000000 		  out
0092	00000000 		  in
0093	00000000 		  in
0094	00000000
0095	00000000
0096	00000000 		  negative  value  index
0097	00000000
0098	00000000
0099	00000000
009A	00000000
009B	0120001F
009C	020000B0
009D	01200000
009E	020000B1
009F	010000B2
00A0	070000B0 		shl
00A1	052000A3
00A2	042000A7
00A3	0120FFFF
00A4	070000B1
00A5	060000B2
00A6	020000B2
00A7	010000B1
00A8	06200001
00A9	020000B1
00AA	010000B0
00AB	0620FFFF
00AC	020000B0
00AD	0520009F
00AE	010000B2
00AF	042000B3
00B0	00000000 		position  relative  to  HO  bit
00B1	00000000 		position  relative  to  LO  bit
00B2	00000000 		NTtoTest
00B3	00000000 		NTtoReturn
00B4	01200000
00B5	020000E5 		  zero  out  carry  bit
00B6	010000E3 		  return  if  no  bits  to  add
00B7	052000B9
00B8	042000E4
00B9	0620FFFF
00BA	020000E3 		  decrement  bit  counter
00BB	01200000 		  zero  out  table  index
00BC	020000E6
00BD	014000E0
00BE	052000C0 		  if  minuend  is  1  then
00BF	042000C3 		  add  4  to  table  index
00C0	010000E6
00C1	06200004
00C2	020000E6
00C3	014000E1
00C4	052000C6 		  if  subtrahend  is  1  then
00C5	042000C9 		  add  2  to  table  index
00C6	010000E6
00C7	06200002
00C8	020000E6
00C9	010000E5
00CA	052000CC 		  if  carry  bit  is  1  then
00CB	042000CF 		  add  1  to  table  index
00CC	010000E6
00CD	06200001
00CE	020000E6
00CF	030000E6
00D0	018000E7 		  look  up  result  table[table  index]
00D1	024000E2 		  assign  to  result
00D2	018000EF 		  look  up  carry  table[table  index]
00D3	020000E5 		  assign  to  carry  bit
00D4	010000E0 		  update  pointer  to  minuend
00D5	06200001
00D6	020000E0
00D7	010000E1 		  update  pointer  to  subtrahend
00D8	06200001
00D9	020000E1
00DA	010000E2 		  update  pointer  to  result
00DB	06200001
00DC	020000E2
00DD	010000E3
00DE	052000B9
00DF	042000E4
00E0	00000000 		  in  -  pointer  to  minuend
00E1	00000000 		  in  -  pointer  to  subtrahend
00E2	00000000 		  out  -  pointer  to  result
00E3	00000000 		  in
00E4	00000000 		  in
00E5	00000000
00E6	00000000
00E7	00000000
00E8	00000001
00E9	00000001
00EA	00000000
00EB	00000001
00EC	00000000
00ED	00000000
00EE	00000001 		consult  truth  table  above  for  details
00EF	00000000
00F0	00000001
00F1	00000001
00F2	00000001
00F3	00000000
00F4	00000000
00F5	00000000
00F6	00000001
00F7	01200000 		  clean  up  (possibly)  dirty  variables
00F8	02000126
00F9	01000121 		  prepare  for  sign  test
00FA	0620FFFF 		  set  current  bit  to  highest  (sign)  bit  position
00FB	02000125
00FC	0100011F 		  set  pointers
00FD	06000125
00FE	02000123
00FF	01000120
0100	06000125
0101	02000124
0102	01000125
0103	05200106
0104	01200000
0105	04200122
0106	0620FFFF
0107	02000125
0108	01000123
0109	0620FFFF
010A	02000123
010B	01000124
010C	0620FFFF
010D	02000124
010E	01400123 		  test  arg  1  bit
010F	05200116 		  if  0  then
0110	01400124 		  test  arg  2  bit
0111	05200113
0112	0420011B 		  continue  loop
0113	0120FFFF 		  if  1  then  it's  case  0-1
0114	02000126 		  result  is  -1
0115	0420011D 		  break
0116	01400124 		  test  arg  2  bit
0117	0520011B 		  if  1  then  it's  case  1-1
0118	01200001 		  if  0  then  it's  case  1-0
0119	02000126 		  result  is  1
011A	0420011D 		  break
011B	01000125
011C	05200106
011D	01000126
011E	04200122 		  return  result
011F	00000000 		  reference  to  first  argument
0120	00000000 		  reference  to  second  argument
0121	00000000 		  length  of  arguments
0122	00000000 		  return  address  and  instruction
0123	00000000 		  pointer  to  current  position  in  argument  1
0124	00000000 		  pointer  to  current  position  in  argument  2
0125	00000000 		  index  of  current  bit  in  argument
0126	00000000 		  result  to  return  to  caller
0127	01200000
0128	02000140
0129	01200020 		number  of  bits  in  an  addressed  value
012A	0620FFFF
012B	02000141 		update  distance  from  big  (left)  end  of  value
012C	01000142 		get  bit
012D	07000141
012E	05200131
012F	01200000 		store  bit  in  accumulator
0130	04200136
0131	0120FFFF
0132	07000140 		if  set  -  clear  this  bit
0133	06000142
0134	02000142
0135	01200001 		store  bit  in  accumulator
0136	02400143 		store  in  unpacked  value
0137	01000143 		increment  pointer  address
0138	06200001
0139	02000143
013A	01000140 		update  current  position
013B	06200001
013C	02000140
013D	01000141 		if  more  bits  to  shift
013E	0520012A 		end  of  loop
013F	04200144
0140	00000000
0141	00000000
0142	00000000 		value  to  unpack
0143	00000000 		pointer  to  unpacked  Value
0144	00000000 		return  to  specified  address
