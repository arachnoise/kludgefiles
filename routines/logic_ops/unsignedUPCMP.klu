0000	0100001D 		prep  for  unpack  of  1st  value
0001	020000AC
0002	01200021
0003	020000AD
0004	0100001C
0005	06200008
0006	020000AE
0007	04200091
0008	0100001E 		prep  for  unpack  of  2nd  value
0009	020000AC
000A	01200041
000B	020000AD
000C	0100001C
000D	06200010
000E	020000AE
000F	04200091
0010	01200021 		prep  for  comparison  function
0011	02000089
0012	01200041
0013	0200008A
0014	0100001F
0015	0200008B
0016	0100001C
0017	0620001A
0018	0200008C
0019	04200061
001A	02000020
001B	08000000
001C	04200000 		jump  instruction  code
001D	00000001 		packed  Value  1
001E	FFFFFFFF 		packed  Value  2
001F	00000020
0020	00000000 		  comparison  result
0021	00000000
0022	00000000
0023	00000000
0024	00000000
0025	00000000
0026	00000000
0027	00000000
0028	00000000
0029	00000000
002A	00000000
002B	00000000
002C	00000000
002D	00000000
002E	00000000
002F	00000000
0030	00000000
0031	00000000
0032	00000000
0033	00000000
0034	00000000
0035	00000000
0036	00000000
0037	00000000
0038	00000000
0039	00000000
003A	00000000
003B	00000000
003C	00000000
003D	00000000
003E	00000000
003F	00000000
0040	00000000
0041	00000000
0042	00000000
0043	00000000
0044	00000000
0045	00000000
0046	00000000
0047	00000000
0048	00000000
0049	00000000
004A	00000000
004B	00000000
004C	00000000
004D	00000000
004E	00000000
004F	00000000
0050	00000000
0051	00000000
0052	00000000
0053	00000000
0054	00000000
0055	00000000
0056	00000000
0057	00000000
0058	00000000
0059	00000000
005A	00000000
005B	00000000
005C	00000000
005D	00000000
005E	00000000
005F	00000000
0060	00000000
0061	01200000 		  clean  up  (possibly)  dirty  variables
0062	02000090
0063	0100008B 		  prepare  for  sign  test
0064	0620FFFF 		  set  current  bit  to  highest  (sign)  bit  position
0065	0200008F
0066	01000089 		  set  pointers
0067	0600008F
0068	0200008D
0069	0100008A
006A	0600008F
006B	0200008E
006C	0100008F
006D	05200070
006E	01200000
006F	0420008C
0070	0620FFFF
0071	0200008F
0072	0100008D
0073	0620FFFF
0074	0200008D
0075	0100008E
0076	0620FFFF
0077	0200008E
0078	0140008D 		  test  arg  1  bit
0079	05200080 		  if  0  then
007A	0140008E 		  test  arg  2  bit
007B	0520007D
007C	04200085 		  continue  loop
007D	0120FFFF 		  if  1  then  it's  case  0-1
007E	02000090 		  result  is  -1
007F	04200087 		  break
0080	0140008E 		  test  arg  2  bit
0081	05200085 		  if  1  then  it's  case  1-1
0082	01200001 		  if  0  then  it's  case  1-0
0083	02000090 		  result  is  1
0084	04200087 		  break
0085	0100008F
0086	05200070
0087	01000090
0088	0420008C 		  return  result
0089	00000000 		  reference  to  first  argument
008A	00000000 		  reference  to  second  argument
008B	00000000 		  length  of  arguments
008C	00000000 		  return  address  and  instruction
008D	00000000 		  pointer  to  current  position  in  argument  1
008E	00000000 		  pointer  to  current  position  in  argument  2
008F	00000000 		  index  of  current  bit  in  argument
0090	00000000 		  result  to  return  to  caller
0091	01200000
0092	020000AA
0093	01200020 		number  of  bits  in  an  addressed  value
0094	0620FFFF
0095	020000AB 		update  distance  from  big  (left)  end  of  value
0096	010000AC 		get  bit
0097	070000AB
0098	0520009B
0099	01200000 		store  bit  in  accumulator
009A	042000A0
009B	0120FFFF
009C	070000AA 		if  set  -  clear  this  bit
009D	060000AC
009E	020000AC
009F	01200001 		store  bit  in  accumulator
00A0	024000AD 		store  in  unpacked  value
00A1	010000AD 		increment  pointer  address
00A2	06200001
00A3	020000AD
00A4	010000AA 		update  current  position
00A5	06200001
00A6	020000AA
00A7	010000AB 		if  more  bits  to  shift
00A8	05200094 		end  of  loop
00A9	042000AE
00AA	00000000
00AB	00000000
00AC	00000000 		value  to  unpack
00AD	00000000 		pointer  to  unpacked  Value
00AE	00000000 		return  to  specified  address

99999
001D 001E 0020 0021 0022 0023 0024 0041 0042 0043 0044