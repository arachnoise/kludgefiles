0000	0100001D 		prep  for  unpack  of  1st  value
0001	020000B9
0002	01200021
0003	020000BA
0004	0100001C
0005	06200008
0006	020000BB
0007	0420009E
0008	0100001E 		prep  for  unpack  of  2nd  value
0009	020000B9
000A	01200041
000B	020000BA
000C	0100001C
000D	06200010
000E	020000BB
000F	0420009E
0010	01200021 		prep  for  comparison  function
0011	02000096
0012	01200041
0013	02000097
0014	0100001F
0015	02000098
0016	0100001C
0017	0620001A
0018	02000099
0019	04200061
001A	02000020
001B	08000000
001C	04200000 		jump  instruction  code
001D	00000001 		packed  Value  1
001E	00000002 		packed  Value  2
001F	00000020
0020	00000000 		  comparison  result
0021	00000000
0022	00000000
0023	00000000
0024	00000000
0025	00000000
0026	00000000
0027	00000000
0028	00000000
0029	00000000
002A	00000000
002B	00000000
002C	00000000
002D	00000000
002E	00000000
002F	00000000
0030	00000000
0031	00000000
0032	00000000
0033	00000000
0034	00000000
0035	00000000
0036	00000000
0037	00000000
0038	00000000
0039	00000000
003A	00000000
003B	00000000
003C	00000000
003D	00000000
003E	00000000
003F	00000000
0040	00000000
0041	00000000
0042	00000000
0043	00000000
0044	00000000
0045	00000000
0046	00000000
0047	00000000
0048	00000000
0049	00000000
004A	00000000
004B	00000000
004C	00000000
004D	00000000
004E	00000000
004F	00000000
0050	00000000
0051	00000000
0052	00000000
0053	00000000
0054	00000000
0055	00000000
0056	00000000
0057	00000000
0058	00000000
0059	00000000
005A	00000000
005B	00000000
005C	00000000
005D	00000000
005E	00000000
005F	00000000
0060	00000000
0061	01200000 		  clean  up  (possibly)  dirty  variables
0062	0200009D
0063	01000098 		  prepare  for  sign  test
0064	0620FFFF 		  set  current  bit  to  highest  (sign)  bit  position
0065	0200009C
0066	01000096 		  set  pointers
0067	0600009C
0068	0200009A
0069	01000097
006A	0600009C
006B	0200009B
006C	0140009A 		  test  arg  1  bit
006D	05200073
006E	0140009B 		  test  arg  2  bit
006F	05200071
0070	04200077 		  start  evaluation
0071	01200001 		  result  is  1
0072	04200099 		  return  with  result
0073	0140009B 		  test  arg  2  bit
0074	05200077
0075	0120FFFF 		  result  is  -1
0076	04200099 		  return  with  result
0077	0100009C
0078	0520007B
0079	01200000
007A	04200099
007B	0620FFFF
007C	0200009C
007D	0100009A
007E	0620FFFF
007F	0200009A
0080	0100009B
0081	0620FFFF
0082	0200009B
0083	0140009A 		  test  arg  1  bit
0084	0520008B 		  if  0  then
0085	0140009B 		  test  arg  2  bit
0086	05200088
0087	04200090 		  continue  loop
0088	0120FFFF 		  if  1  then  it's  case  0-1
0089	0200009D 		  result  is  -1
008A	04200094 		  break
008B	0140009B 		  test  arg  2  bit
008C	05200090 		  if  1  then  it's  case  1-1
008D	01200001 		  if  0  then  it's  case  1-0
008E	0200009D 		  result  is  1
008F	04200094 		  break
0090	0100009C
0091	0520007B
0092	0100009D
0093	04200099
0094	0100009D
0095	04200099 		  return  result
0096	00000000 		  reference  to  first  argument
0097	00000000 		  reference  to  second  argument
0098	00000000 		  length  of  arguments
0099	00000000 		  return  address  and  instruction
009A	00000000 		  pointer  to  current  position  in  argument  1
009B	00000000 		  pointer  to  current  position  in  argument  2
009C	00000000 		  index  of  current  bit  in  argument
009D	00000000 		  result  to  return  to  caller
009E	01200000
009F	020000B7
00A0	01200020 		number  of  bits  in  an  addressed  value
00A1	0620FFFF
00A2	020000B8 		update  distance  from  big  (left)  end  of  value
00A3	010000B9 		get  bit
00A4	070000B8
00A5	052000A8
00A6	01200000 		store  bit  in  accumulator
00A7	042000AD
00A8	0120FFFF
00A9	070000B7 		if  set  -  clear  this  bit
00AA	060000B9
00AB	020000B9
00AC	01200001 		store  bit  in  accumulator
00AD	024000BA 		store  in  unpacked  value
00AE	010000BA 		increment  pointer  address
00AF	06200001
00B0	020000BA
00B1	010000B7 		update  current  position
00B2	06200001
00B3	020000B7
00B4	010000B8 		if  more  bits  to  shift
00B5	052000A1 		end  of  loop
00B6	042000BB
00B7	00000000
00B8	00000000
00B9	00000000 		value  to  unpack
00BA	00000000 		pointer  to  unpacked  Value
00BB	00000000 		return  to  specified  address

99999
001D 001E 0020